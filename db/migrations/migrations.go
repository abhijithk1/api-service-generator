package migrations

import (
	"fmt"
	"strings"

	"github.com/abhijithk1/api-service-generator/common"
	"github.com/abhijithk1/api-service-generator/models"
	_ "github.com/lib/pq"
)

var (
	MigrateCreateTemplate  = `migrate create -ext sql -dir %s/pkg/db/migrations -seq init_schema`
	migrationDirectoryPath = "/pkg/db/migrations/"
	migrationUpFileName    = "000001_init_schema.up.sql"
	migrationDownFileName  = "000001_init_schema.down.sql"
	migrationUpFilePath    = "/pkg/db/"
	// MigrateUpCmd             = `migrate -path %s/pkg/db/migrations -database "%s" -verbose up`
)

type MigrationInterface interface {
	Migration(dbInputs models.DBInputs, initSchema models.InitSchema) (err error)
	RunMigration(dbInputs models.DBInputs) error
}

var DefaultMigrationClient MigrationInterface = &MigrationClient{}

type MigrationClient struct{}

func (m * MigrationClient) Migration(dbInputs models.DBInputs, initSchema models.InitSchema) (err error) {
	fmt.Println("\n\n*** Migrating starts....")
	err = initialiseMigration(dbInputs.WrkDir)
	if err != nil {
		return
	}

	fmt.Println("\n\n*** Init Schema Generated ***")
	fmt.Println("\n\n*** Writing into the up schema ***")
	err = writeSchemaUpFile(initSchema)
	if err != nil {
		return
	}

	fmt.Println("\n\n*** Writing into the down schema ***")
	err = writeSchemaDownFile(initSchema)
	if err != nil {
		return
	}

	fmt.Println("\n\n*** Up migration  ***")

	return nil
}

func (m *MigrationClient) RunMigration(dbInputs models.DBInputs) error {
	fileName := dbInputs.WrkDir + migrationUpFilePath + "migrate.go"
	return common.CreateFileAndItsContent(fileName, dbInputs, migrateUp_content)
}

func Migration(dbInputs models.DBInputs, initSchema models.InitSchema) (err error) {
	return DefaultMigrationClient.Migration(dbInputs, initSchema)
}

func initialiseMigration(wrkDir string) (err error) {
	creatdCmd := fmt.Sprintf(MigrateCreateTemplate, wrkDir)
	cmdSplits := strings.Split(creatdCmd, " ")

	fmt.Println("\nRunning Command : ", creatdCmd)

	output, err := common.ExecuteCmds(cmdSplits[0], cmdSplits[1:], ".")
	if err != nil {
		fmt.Printf("\nError running command: %s\nOutput: %s\n", err, output)
		return
	}

	return nil
}

var init_schema_up = `/*
Generated using API Service Generator
*/

CREATE TABLE IF NOT EXISTS {{.TableName}} (
    id                          SERIAL PRIMARY KEY,
    name                  		VARCHAR(255)
);

`

var init_schema_down = `/*
Generated using API Service Generator
*/

DROP TABLE IF EXISTS {{.TableName}};

`

func writeSchemaUpFile(initSchema models.InitSchema) error {
	fileName := initSchema.WrkDir + migrationDirectoryPath + migrationUpFileName
	return common.CreateFileAndItsContent(fileName, initSchema, init_schema_up)
}

func writeSchemaDownFile(initSchema models.InitSchema) error {
	fileName := initSchema.WrkDir + migrationDirectoryPath + migrationDownFileName
	return common.CreateFileAndItsContent(fileName, initSchema, init_schema_down)
}

const migrateUp_content = `// Generated By API Service Generator

package db

import (
	"database/sql"
	util "{{.GoModule}}/{{.WrkDir}}/utils"

    _ "{{.DriverPackage}}"
	"github.com/IBM/alchemy-logging/src/go/alog"
    "github.com/golang-migrate/migrate/v4"
    "github.com/golang-migrate/migrate/v4/database/{{.DBMS}}"
    _ "github.com/golang-migrate/migrate/v4/source/file"
)

func RunMigration(db *sql.DB, targetRevision int) (err error) {
	dbDriver := util.GetAppConfig().DBDriver
	driver, err := {{.DBMS}}.WithInstance(db, &{{.DBMS}}.Config{})
	if err != nil {
		return
	}
	m, err := migrate.NewWithDatabaseInstance(
		"file://pkg/db/migrations",
		dbDriver, driver)
	if err != nil {
		return
	}

	currentVersion, _, err := m.Version()
	if err != nil && err != migrate.ErrNilVersion {
		return err
	}

	// Determine the steps needed to reach the target revision
	steps := targetRevision - int(currentVersion)
	if steps == 0 {
		ch.Log(alog.INFO, "Database is already at the target revision.")
		return nil
	}

	if err = m.Steps(steps); err != nil {
		return err
	}

	ch.Log(alog.INFO, "Database migrated to revision %d\n", targetRevision)
	return nil
}
`

func RunMigration(dbInputs models.DBInputs) error {
	return DefaultMigrationClient.RunMigration(dbInputs)
}
