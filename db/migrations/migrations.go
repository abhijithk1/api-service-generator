package migrations

import (
	"fmt"
	"strings"

	"github.com/abhijithk1/api-service-generator/common"
	"github.com/abhijithk1/api-service-generator/models"
	_ "github.com/lib/pq"
)

var (
	MigrateCreateTemplate  = `migrate create -ext sql -dir %s/pkg/db/migrations -seq init_schema`
	PostgresqlUrl          = "postgres://%s:%s@localhost:6432/%s?sslmode=disable"
	MigrateDown            = `migrate -path %s/pkg/db/migrations -database "%s" -verbose down`
	migrationDirectoryPath = "/pkg/db/migrations/"
	migrationUpFileName    = "000001_init_schema.up.sql"
	migrationDownFileName  = "000001_init_schema.down.sql"
	migrationUpFilePath    = "/pkg/db/"
	// MigrateUpCmd             = `migrate -path %s/pkg/db/migrations -database "%s" -verbose up`
)

func PostgresMigration(dbInputs models.DBInputs, initSchema models.InitSchema) (err error) {
	fmt.Println("\n\n*** Migrating starts....")
	err = initialiseMigration(dbInputs.WrkDir)
	if err != nil {
		return
	}

	fmt.Println("\n\n*** Init Schema Generated ***")
	fmt.Println("\n\n*** Writing into the up schema ***")
	err = writeSchemaUpFile(initSchema)
	if err != nil {
		return
	}

	fmt.Println("\n\n*** Writing into the down schema ***")
	err = writeSchemaDownFile(initSchema)
	if err != nil {
		return
	}

	fmt.Println("\n\n*** Up migration  ***")

	return nil
}

func initialiseMigration(wrkDir string) (err error) {
	MigrateCreateTemplate = fmt.Sprintf(MigrateCreateTemplate, wrkDir)
	cmdSplits := strings.Split(MigrateCreateTemplate, " ")

	fmt.Println("\nRunning Command : ", MigrateCreateTemplate)

	output, err := common.ExecuteCmds(cmdSplits[0], cmdSplits[1:], ".")
	if err != nil {
		fmt.Printf("\nError running command: %s\nOutput: %s\n", err, output)
		return
	}

	return nil
}

var init_schema_up = `/*
Generated using API Service Generator
*/

CREATE TABLE IF NOT EXISTS {{.TableName}} (
    id                          SERIAL PRIMARY KEY,
    name                  		VARCHAR(255)
);

`

var init_schema_down = `/*
Generated using API Service Generator
*/

DROP TABLE IF EXISTS {{.TableName}};

`

func writeSchemaUpFile(initSchema models.InitSchema) error {
	fileName := initSchema.WrkDir + migrationDirectoryPath + migrationUpFileName
	fmt.Println("filename : ", fileName)
	return common.CreateFileAndItsContent(fileName, initSchema, init_schema_up)
}

func writeSchemaDownFile(initSchema models.InitSchema) error {
	fileName := initSchema.WrkDir + migrationDirectoryPath + migrationDownFileName
	fmt.Println("filename : ", fileName)
	return common.CreateFileAndItsContent(fileName, initSchema, init_schema_down)
}

const migrateUp_content = `/*
Generated By API Service Generator
*/

package db

import (
	"database/sql"

    _ "github.com/lib/pq"
    "github.com/golang-migrate/migrate/v4"
    "github.com/golang-migrate/migrate/v4/database/postgres"
    _ "github.com/golang-migrate/migrate/v4/source/file"
)

func RunMigration(db *sql.DB, targetRevision int) (err error) {
	driver, err := postgres.WithInstance(db, &postgres.Config{})
	if err != nil {
		return
	}
	m, err := migrate.NewWithDatabaseInstance(
		"postgres://postgres:password@localhost:6432/postgres?sslmode=disable",
		"postgres", driver)
	if err != nil {
		return
	}

	currentVersion, _, err := m.Version()
	if err != nil && err != migrate.ErrNilVersion {
		return err
	}

	// Determine the steps needed to reach the target revision
	steps := targetRevision - int(currentVersion)
	if steps == 0 {
		ch.Log(alog.INFO, "Database is already at the target revision.")
		return nil
	}

	if err = m.Steps(steps); err != nil {
		return err
	}

	ch.Log(alog.INFO, "Database migrated to revision %d\n", targetRevision)
	return nil
}
`

func RunMigration(dbInputs models.DBInputs) error {
	PostgresqlUrl = fmt.Sprintf(PostgresqlUrl, dbInputs.PsqlUser, dbInputs.PsqlPassword, dbInputs.DBName)
	fileName := dbInputs.WrkDir + migrationUpFilePath + "migrate.go"
	return common.CreateFileAndItsContent(fileName, models.Migration{PostgresqlUrl: PostgresqlUrl}, migrateUp_content)
}
