package finalsetup

import (
	"fmt"

	"github.com/abhijithk1/api-service-generator/common"
	"github.com/abhijithk1/api-service-generator/models"
)

func FinalSetup(apiInputs models.APIInputs, dbInputs models.DBInputs) (err error) {
	err = createMainFile(apiInputs)
	if err != nil {
		fmt.Println("Error : ", err)
		return
	}

	err = createENVFile(dbInputs)
	if err != nil {
		fmt.Println("Error : ", err)
		return
	}

	err = createMakeFile(apiInputs.WrkDir)
	if err != nil {
		fmt.Println("Error : ", err)
		return
	}

	return nil
}

const mainContent = `// Generated By API Service Generator
package main

import (
	"{{.GoModule}}/{{.WrkDir}}/api/v1/{{.APIGroup}}"
	"{{.GoModule}}/{{.WrkDir}}/api/v1/mw/auth"
	"{{.GoModule}}/{{.WrkDir}}/api/v1/mw/cors"
	"{{.GoModule}}/{{.WrkDir}}/pkg/db"
	util "{{.GoModule}}/{{.WrkDir}}/utils"
	"net/http"

	"github.com/IBM/alchemy-logging/src/go/alog"
	"github.com/gin-gonic/gin"
)

var ch = alog.UseChannel("MAIN")

const DB_REVISION = 1

func setupRouter({{.APIGroup}}Svc {{.APIGroup}}.Service) *gin.Engine {
	router := gin.New()

	router.Use(gin.LoggerWithConfig(gin.LoggerConfig{
		SkipPaths: []string{"/health"},
	}), gin.Recovery())

	router.Use(cors.CORSMiddleware())

	v1 := router.Group("/v1")
	v1.Use(auth.AuthMiddleware())

	{{.APIGroup}}.RegisterHandler(v1, {{.APIGroup}}Svc)

	router.NoRoute(func(c *gin.Context) {
		c.JSON(http.StatusNotFound, gin.H{"code": "404_NOT_FOUND", "message": "No URL found"})
	})

	return router
}

func main() {
	util.StartLogServer()
	conn := db.GetConnection()

	defer conn.Close()

	err := db.RunMigration(conn, DB_REVISION)
	if err != nil {
		ch.Log(alog.ERROR, "Failed to migrate: %v", err)
		return
	}

	queries := db.New(conn)

	{{.APIGroup}}Svc := {{.APIGroup}}.New{{.APIGroupTitle}}Service(queries)

	router := setupRouter(&{{.APIGroup}}Svc)

	ch.Log(alog.INFO, "Server listening on port 8080")
	router.Run(":8080")
}
`

func createMainFile(apiInputs models.APIInputs) error {
	fileName := apiInputs.WrkDir + "/main.go"
	apiInputs.APIGroupTitle = common.ToCamelCase(apiInputs.APIGroup)
	return common.CreateFileAndItsContent(fileName, apiInputs, mainContent)
}

const envFile = `# Generated By API Service Generator

DB_DRIVER={{.DBMS}}
DB_SOURCE={{.DBMS}}://{{.PsqlUser}}:{{.PsqlPassword}}@localhost:{{.ContainerPort}}/{{.DBName}}?sslmode=disable
SECURE=false
AUTH=false
`

func createENVFile(dbInputs models.DBInputs) error {
	envFileName := dbInputs.WrkDir + "/app.env"
	return common.CreateFileAndItsContent(envFileName, dbInputs, envFile)
}

const makeFileContent = `# Generated By API Service Generator

include app.env

migrateup:
	migrate -path pkg/db/migrations -database "$(DB_SOURCE)" -verbose up

migratedown:
	migrate -path db/migration -database "$(DB_SOURCE)" -verbose down

run: ## run the api-service
	go run main.go

test: # run unit tests
	go test -v -coverprofile=coverage.out ./...
	go tool cover -func=coverage.out
	go tool cover -html=coverage.out -o coverage.html

build: ## build the offload-service binary
	CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o main main.go

sqlc: ## run all new database migrations
	@echo "Running sqlc code generation..."
	sqlc generate

.PHONY: migrateup, migratedown, run, test, build, sqlc

`

func createMakeFile(wrkDir string) error {
	fileName := wrkDir + "/Makefile"
	return common.CreateFileAndItsContent(fileName, nil, makeFileContent)
}