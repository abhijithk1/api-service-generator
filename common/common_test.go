package common

import (
	"errors"
	"fmt"
	"os"
	"strings"
	"testing"

	"github.com/abhijithk1/api-service-generator/mocks"
	"github.com/abhijithk1/api-service-generator/models"
	"github.com/stretchr/testify/assert"
)

func TestMain(m *testing.M) {
	os.Exit(m.Run())
}

func TestCommandExecuter_CreateDirectory(t *testing.T) {

	path := "exampleDir"

	executer := &realCommandExecutor{}

	err := executer.CreateDirectory(path)

	assert.NoError(t, err)
	assert.DirExists(t, path)

	defer func() {
		err = os.RemoveAll(path)
		assert.NoError(t, err)
		assert.NoDirExists(t, path)
	}()
}

func TestCreateDirectory(t *testing.T) {

	mockExec := mocks.NewMockCmdsExecutor()

	path := "test_dir"

	mockExec.On("CreateDirectory", path).Return(nil)

	executor := mockExec

	// Create Directory
	err := executor.CreateDirectory(path)
	assert.NoError(t, err)

	mockExec.AssertExpectations(t)
}

func TestCommandExecuter_ExecuteCmds(t *testing.T) {

	// Set up test data
	cmdStr := "ls"
	cmdArgs := []string{"-l"}

	pwd, _ := os.Getwd()

	executor := &realCommandExecutor{}

	_, err := executor.ExecuteCmds(cmdStr, cmdArgs, pwd)

	assert.NoError(t, err)

}

func TestExecuteCmds(t *testing.T) {

	mockExec := mocks.NewMockCmdsExecutor()

	// Set up test data
	cmdStr := "ls"
	cmdArgs := []string{"-l"}
	pwd := "file"

	mockExec.On("ExecuteCmds", cmdStr, cmdArgs, pwd).Return([]byte(""), nil)

	executor := mockExec

	_, err := executor.ExecuteCmds(cmdStr, cmdArgs, pwd)
	assert.NoError(t, err)

	mockExec.AssertExpectations(t)
}

type TestFileData struct {
	PackageName  string
	FunctionName string
}

func TestCreateFileAndItsContent_Success(t *testing.T) {
	// Create File and its content
	fileName := "test_file.go"
	fileContent := `// Generated By API Service Generator

	package {{.PackageName}}

	import "fmt"
	
	// {{.FunctionName}} is a function to Test and prints hello message
	func {{.FunctionName}}() {
		fmt.Println("hello")
	}
	`

	fileData := TestFileData{
		PackageName:  "common",
		FunctionName: "testingFunction",
	}

	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	assert.NoError(t, err)
	assert.FileExists(t, fileName)

	content, err := os.ReadFile(fileName)
	assert.NoError(t, err)
	assert.NotEmpty(t, content)

	// Convert content to a string
	contentStr := string(content)

	// Define expected content with actual values substituted
	expectedContent := `// Generated By API Service Generator

	package common

	import "fmt"
	
	// testingFunction is a function to Test and prints hello message
	func testingFunction() {
		fmt.Println("hello")
	}
	`

	assert.Equal(t, normalizeWhitespace(expectedContent), normalizeWhitespace(contentStr))

	// Clean up: Remove file and its content
	defer func() {
		err = os.Remove(fileName)
		assert.NoError(t, err)
		assert.NoFileExists(t, fileName)
	}()
}

func normalizeWhitespace(s string) string {
	return strings.Join(strings.Fields(s), " ")
}

func TestCreateFileAndItsContent_ErrorInCreatingFile(t *testing.T) {
	// Define an invalid file path
	fileName := "/invalid_dir/test_file.go"
	fileContent := `
	package {{.PackageName}} 
	func {{.FunctionName}}() {}
	`
	fileData := TestFileData{
		PackageName:  "common",
		FunctionName: "testingFunction",
	}

	// Attempt to create file with invalid path
	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error creating file")
}

func TestCreateFileAndItsContent_ErrorInParsingTemplate(t *testing.T) {
	// Define a file path
	fileName := "test_file.go"
	fileContent := `
	package {{.PackageName} 
	func {{.FunctionName}}() {}
	`
	fileData := TestFileData{
		PackageName:  "common",
		FunctionName: "testingFunction",
	}

	// Attempt to create file with invalid template
	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error parsing template")

	// Clean up: Remove file if it was created
	defer func() {
		err = os.Remove(fileName)
		if err == nil || os.IsNotExist(err) {
			assert.NoFileExists(t, fileName)
		}
	}()
}

func TestCreateFileAndItsContent_ErrorInExecutingTemplate(t *testing.T) {
	// Define a file path
	fileName := "test_file.go"
	fileContent := `
	package {{.PackageName}} 
	func {{.FunctionName}}() {}
	`
	fileData := struct {
		ErrorField string
	}{
		ErrorField: "error",
	}

	// Attempt to create file with mismatched data
	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error executing template")

	// Clean up: Remove file if it was created
	defer func() {
		err = os.Remove(fileName)
		if err == nil || os.IsNotExist(err) {
			assert.NoFileExists(t, fileName)
		}
	}()
}

func TestExecuteGoMod_Success(t *testing.T) {
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	path := "example/path"
	name := "example"
	modName := fmt.Sprintf("%s/%s", path, name)
	cmdStr := "go"
	cmdArgs := []string{"mod", "init", modName}

	mockExec.On("ExecuteCmds", cmdStr, cmdArgs, name).Return([]byte(""), nil)

	err := ExecuteGoMod(path, name)
	assert.NoError(t, err)
	mockExec.AssertExpectations(t)

}

func TestExecuteGoMod_MockError(t *testing.T) {
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	path := "example/path"
	name := "example"
	modName := fmt.Sprintf("%s/%s", path, name)
	cmdStr := "go"
	cmdArgs := []string{"mod", "init", modName}

	mockExec.On("ExecuteCmds", cmdStr, cmdArgs, name).Return([]byte(""), errors.New("error in initialising go module"))

	err := ExecuteGoMod(path, name)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error in initialising go module")
	mockExec.AssertExpectations(t)
}

func TestExecuteGoGets_Success(t *testing.T) {
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	wrkDir := "dir"

	DependentPackages = []string{"github.com/some/package", "github.com/another/package"}
	cmdStr := "go"
	CmdArgs1 := []string{"get", "github.com/some/package"}
	CmdArgs2 := []string{"get", "github.com/another/package"}

	mockExec.On("ExecuteCmds", cmdStr, CmdArgs1, wrkDir).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdStr, CmdArgs2, wrkDir).Return([]byte(""), nil)

	err := ExecuteGoGets(wrkDir)
	assert.NoError(t, err)
	mockExec.AssertExpectations(t)
}

func TestExecuteGoGets_Error(t *testing.T) {
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	wrkDir := "dir"

	DependentPackages = []string{"github.com/some/package"}
	cmdStr := "go"
	CmdArgs := []string{"get", "github.com/some/package"}

	mockExec.On("ExecuteCmds", cmdStr, CmdArgs, wrkDir).Return([]byte(""), errors.New("error in downloading go package"))

	err := ExecuteGoGets(wrkDir)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error in downloading go package")
	mockExec.AssertExpectations(t)
}

func TestInitialise_SuccessPostgres(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	dbInputs := models.DBInputs{
		DBMS: "postgres",
		WrkDir: "example",
	}
	modName := fmt.Sprintf("%s/%s", path, dbInputs.WrkDir)
	initialDirs := []string{"dir1", "dir2"}
	InitialDirectories = initialDirs
	DependentPackages = []string{"github.com/some/package"}

	cmdGoStr := "go"
	cmdArgs1 := []string{"mod", "init", modName}
	cmdArgs2 := []string{"get", "github.com/some/package"}
	cmdArgs3 := []string{"get", "github.com/lib/pq"}

	// Set up mock expectations
	mockExec.On("CreateDirectory", dbInputs.WrkDir).Return(nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs1, dbInputs.WrkDir).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs2, dbInputs.WrkDir).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs3, dbInputs.WrkDir).Return([]byte(""), nil)
	for _, dir := range initialDirs {
		dir = dbInputs.WrkDir + dir
		mockExec.On("CreateDirectory", dir).Return(nil)
	}

	Initialise(path, &dbInputs)

	mockExec.AssertExpectations(t)

}

func TestInitialise_SuccessMySql(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	dbInputs := models.DBInputs{
		DBMS: "mysql",
		WrkDir: "example",
	}
	modName := fmt.Sprintf("%s/%s", path, dbInputs.WrkDir)
	initialDirs := []string{"dir1", "dir2"}
	InitialDirectories = initialDirs
	DependentPackages = []string{"github.com/some/package"}

	cmdGoStr := "go"
	cmdArgs1 := []string{"mod", "init", modName}
	cmdArgs2 := []string{"get", "github.com/some/package"}
	cmdArgs3 := []string{"get", "github.com/go-sql-driver/mysql"}

	// Set up mock expectations
	mockExec.On("CreateDirectory", dbInputs.WrkDir).Return(nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs1, dbInputs.WrkDir).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs2, dbInputs.WrkDir).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs3, dbInputs.WrkDir).Return([]byte(""), nil)
	for _, dir := range initialDirs {
		dir = dbInputs.WrkDir + dir
		mockExec.On("CreateDirectory", dir).Return(nil)
	}

	Initialise(path, &dbInputs)

	mockExec.AssertExpectations(t)

}

func TestInitialise_ErrorCreateDirectory(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	dbInputs := models.DBInputs{
		DBMS: "postgres",
		WrkDir: "example",
	}

	// Set up mock expectations
	mockExec.On("CreateDirectory", dbInputs.WrkDir).Return(errors.New("error in creating file"))

	Initialise(path, &dbInputs)

	mockExec.AssertExpectations(t)

}

func TestInitialise_ErrorExecutingGoMod(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	dbInputs := models.DBInputs{
		DBMS: "postgres",
		WrkDir: "example",
	}
	modName := fmt.Sprintf("%s/%s", path, dbInputs.WrkDir)
	cmdGoStr := "go"
	cmdArgs1 := []string{"mod", "init", modName}

	// Set up mock expectations
	mockExec.On("CreateDirectory", dbInputs.WrkDir).Return(nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs1, dbInputs.WrkDir).Return([]byte(""), errors.New("error in go mod command"))

	Initialise(path, &dbInputs)

	mockExec.AssertExpectations(t)

}

func TestInitialise_ErrorExecutingGoGets(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	dbInputs := models.DBInputs{
		DBMS: "postgres",
		WrkDir: "example",
	}
	modName := fmt.Sprintf("%s/%s", path, dbInputs.WrkDir)
	cmdGoStr := "go"
	cmdArgs1 := []string{"mod", "init", modName}
	cmdArgs2 := []string{"get", "github.com/some/package"}
	DependentPackages = []string{"github.com/some/package"}

	// Set up mock expectations
	mockExec.On("CreateDirectory", dbInputs.WrkDir).Return(nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs1, dbInputs.WrkDir).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs2, dbInputs.WrkDir).Return([]byte(""), errors.New("error executing go get command"))

	Initialise(path, &dbInputs)

	mockExec.AssertExpectations(t)
}

func TestInitialise_ErrorCreatingInitalDirectories(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	dbInputs := models.DBInputs{
		DBMS: "postgres",
		WrkDir: "example",
	}
	modName := fmt.Sprintf("%s/%s", path, dbInputs.WrkDir)
	initialDirs := []string{"dir1"}
	InitialDirectories = initialDirs
	DependentPackages = []string{"github.com/some/package"}

	cmdGoStr := "go"
	cmdArgs1 := []string{"mod", "init", modName}
	cmdArgs2 := []string{"get", "github.com/some/package"}
	cmdArgs3 := []string{"get", "github.com/lib/pq"}

	// Set up mock expectations
	mockExec.On("CreateDirectory", dbInputs.WrkDir).Return(nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs1, dbInputs.WrkDir).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs2, dbInputs.WrkDir).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs3, dbInputs.WrkDir).Return([]byte(""), nil)
	for _, dir := range InitialDirectories {
		dir = dbInputs.WrkDir + dir
		mockExec.On("CreateDirectory", dir).Return(errors.New("error creating initial directory"))
	}

	Initialise(path, &dbInputs)

	mockExec.AssertExpectations(t)
}

func TestToCamelCase(t *testing.T) {
	str := "dummy_string"
	expectedStr := "DummyString"
	
	newStr := ToCamelCase(str)
	assert.Equal(t, expectedStr, newStr)
}

func TestCapitalise(t *testing.T) {
	str1 := "dummy"
	exprectedStr1 := "Dummy"

	newStr1 := capitalize(str1)
	assert.Equal(t, exprectedStr1, newStr1)

	str2 := ""

	newStr2 := capitalize(str2)
	assert.Equal(t, "", newStr2)
}

func TestIsValidString(t *testing.T) {
	str := "new-str"

	expectedResult := false
	 result := IsValidString(str)

	 assert.Equal(t, expectedResult, result)

	 str = "new_str"
	 expectedResult = true

	 result = IsValidString(str)

	 assert.Equal(t, expectedResult, result)
}
