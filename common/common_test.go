package common

import (
	"errors"
	"fmt"
	"os"
	"strings"
	"testing"

	"github.com/abhijithk1/api-service-generator/mocks"
	"github.com/stretchr/testify/assert"
)

func TestMain(m *testing.M) {
	os.Exit(m.Run())
}

func TestCommandExecuter_CreateDirectory(t *testing.T) {

	path := "exampleDir"

	executer := &realCommandExecutor{}

	err := executer.CreateDirectory(path)

	assert.NoError(t, err)
	assert.DirExists(t, path)
	
	defer func() {
		err = os.RemoveAll(path)
		assert.NoError(t, err)
		assert.NoDirExists(t, path)
	}()
}

func TestCreateDirectory(t *testing.T) {

	mockExec := mocks.NewMockCmdsExecutor()

	path := "test_dir"

	mockExec.On("CreateDirectory", path).Return(nil)

	executor := mockExec

	// Create Directory
	err := executor.CreateDirectory(path)
	assert.NoError(t, err)

	mockExec.AssertExpectations(t)
}

func TestCommandExecuter_ExecuteCmds(t *testing.T) {

	// Set up test data
    cmdStr := "ls"
    cmdArgs := []string{"-l"}

	executor := &realCommandExecutor{}

	_, err := executor.ExecuteCmds(cmdStr, cmdArgs)

	assert.NoError(t, err)

}

func TestExecuteCmds(t *testing.T) {

	mockExec := mocks.NewMockCmdsExecutor()

	// Set up test data
    cmdStr := "ls"
    cmdArgs := []string{"-l"}

	mockExec.On("ExecuteCmds", cmdStr, cmdArgs).Return([]byte(""), nil)

	executor := mockExec

	_, err := executor.ExecuteCmds(cmdStr, cmdArgs)
	assert.NoError(t, err)

	mockExec.AssertExpectations(t)
}

type TestFileData struct {
	PackageName  string
	FunctionName string
}

func TestCreateFileAndItsContent_Success(t *testing.T) {
	// Create File and its content
	fileName := "test_file.go"
	fileContent := `
	//Generated By API Service Generator

	package {{.PackageName}}

	import "fmt"
	
	// {{.FunctionName}} is a function to Test and prints hello message
	func {{.FunctionName}}() {
		fmt.Println("hello")
	}
	`

	fileData := TestFileData{
		PackageName:  "common",
		FunctionName: "testingFunction",
	}

	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	assert.NoError(t, err)
	assert.FileExists(t, fileName)

	content, err := os.ReadFile(fileName)
	assert.NoError(t, err)
	assert.NotEmpty(t, content)

	// Convert content to a string
	contentStr := string(content)

	// Define expected content with actual values substituted
	expectedContent := `
	//Generated By API Service Generator

	package common

	import "fmt"
	
	// testingFunction is a function to Test and prints hello message
	func testingFunction() {
		fmt.Println("hello")
	}
	`

	assert.Equal(t, normalizeWhitespace(expectedContent), normalizeWhitespace(contentStr))

	// Clean up: Remove file and its content
	defer func() {
		err = os.Remove(fileName)
		assert.NoError(t, err)
		assert.NoFileExists(t, fileName)
	}()
}

func normalizeWhitespace(s string) string {
	return strings.Join(strings.Fields(s), " ")
}

func TestCreateFileAndItsContent_ErrorInCreatingFile(t *testing.T) {
	// Define an invalid file path
	fileName := "/invalid_dir/test_file.go"
	fileContent := `
	package {{.PackageName}} 
	func {{.FunctionName}}() {}
	`
	fileData := TestFileData{
		PackageName:  "common",
		FunctionName: "testingFunction",
	}

	// Attempt to create file with invalid path
	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error creating file")
}

func TestCreateFileAndItsContent_ErrorInParsingTemplate(t *testing.T) {
	// Define a file path
	fileName := "test_file.go"
	fileContent := `
	package {{.PackageName} 
	func {{.FunctionName}}() {}
	`
	fileData := TestFileData{
		PackageName:  "common",
		FunctionName: "testingFunction",
	}

	// Attempt to create file with invalid template
	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error parsing template")

	// Clean up: Remove file if it was created
	defer func() {
		err = os.Remove(fileName)
		if err == nil || os.IsNotExist(err) {
			assert.NoFileExists(t, fileName)
		}
	}()
}

func TestCreateFileAndItsContent_ErrorInExecutingTemplate(t *testing.T) {
	// Define a file path
	fileName := "test_file.go"
	fileContent := `
	package {{.PackageName}} 
	func {{.FunctionName}}() {}
	`
	fileData := struct {
		ErrorField string
	}{
		ErrorField: "error",
	}

	// Attempt to create file with mismatched data
	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error executing template")

	// Clean up: Remove file if it was created
	defer func() {
		err = os.Remove(fileName)
		if err == nil || os.IsNotExist(err) {
			assert.NoFileExists(t, fileName)
		}
	}()
}

func TestExecuteGoMod_Success(t *testing.T) {
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	path := "example/path"
	name := "example"
	modName := fmt.Sprintf("%s/%s", path, name)
	cmdStr := "go"
	cmdArgs := []string{"mod", "init", modName}

	mockExec.On("ExecuteCmds", cmdStr, cmdArgs).Return([]byte(""),nil)

	err := ExecuteGoMod(path, name)
	assert.NoError(t, err)
	mockExec.AssertExpectations(t)

}

func TestExecuteGoMod_MockError(t *testing.T) {
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	path := "example/path"
	name := "example"
	modName := fmt.Sprintf("%s/%s", path, name)
	cmdStr := "go"
	cmdArgs := []string{"mod", "init", modName}

	mockExec.On("ExecuteCmds", cmdStr, cmdArgs).Return([]byte(""),errors.New("error in initialising go module"))

	err := ExecuteGoMod(path, name)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error in initialising go module")
	mockExec.AssertExpectations(t)
}


func TestExecuteGoGets_Success(t *testing.T) {
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	DependentPackages = []string{"github.com/some/package", "github.com/another/package"}
	cmdStr := "go"
	CmdArgs1 := []string{"get", "github.com/some/package"}
	CmdArgs2 := []string{"get", "github.com/another/package"}

	mockExec.On("ExecuteCmds", cmdStr, CmdArgs1).Return([]byte(""),nil)
	mockExec.On("ExecuteCmds", cmdStr, CmdArgs2).Return([]byte(""),nil)


	err := ExecuteGoGets()
	assert.NoError(t, err)
	mockExec.AssertExpectations(t)
}

func TestExecuteGoGets_Error(t *testing.T) {
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	DependentPackages = []string{"github.com/some/package"}
	cmdStr := "go"
	CmdArgs := []string{"get", "github.com/some/package"}

	mockExec.On("ExecuteCmds", cmdStr, CmdArgs).Return([]byte(""),errors.New("error in downloading go package"))

	err := ExecuteGoGets()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error in downloading go package")
	mockExec.AssertExpectations(t)
}

func TestInitialise_Success(t *testing.T) {
	 // Create a mock executor
	 mockExec := mocks.NewMockCmdsExecutor()
	 DefaultExecutor = mockExec
 
	 // Set up test data
	 path := "example/path"
	 name := "example"
	 modName := fmt.Sprintf("%s/%s", path, name) 
	 initialDirs := []string{"dir1", "dir2"}
	 InitialDirectories = initialDirs
	 DependentPackages = []string{"github.com/some/package"}

	 cmdGoStr := "go"
	 cmdArgs1 := []string{"mod", "init", modName}
	 cmdArgs2 := []string{"get", "github.com/some/package"}
 
	 // Set up mock expectations
	 mockExec.On("CreateDirectory", name).Return(nil)
	 mockExec.On("ExecuteCmds", "cd", []string{name}).Return([]byte(""), nil)
	 mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs1).Return([]byte(""), nil)
	 mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs2).Return([]byte(""), nil)
	 for _, dir := range initialDirs {
		 mockExec.On("CreateDirectory", dir).Return(nil)
	 }
 
	//  // Capture the output of Initialise
	//  output := captureOutput(func() {
	// })
	Initialise(path, name)
 
	//  // Assertions
	//  assert.Contains(t, output, fmt.Sprintf("*** Creating the Service Directory %s ***", name))
	//  assert.Contains(t, output, fmt.Sprintf("*** Successfully created the Service Directory %s ***", name))
	//  assert.Contains(t, output, "*** Creating go.mod ***")
	//  assert.Contains(t, output, "*** Successfully created go.mod ***")
	//  assert.Contains(t, output, "*** Updating go packages ***")
	//  assert.Contains(t, output, "*** Successfully updated go packages ***")
	//  assert.Contains(t, output, "*** the initial Directories ***")
	//  assert.Contains(t, output, "*** *** Successfully Created the initial Directories ***")
 
	 // Assert that all expectations on the mock were met
	 mockExec.AssertExpectations(t)
	
}

func TestInitialise_ErrorCreateDirectory(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	name := "example"

	// Set up mock expectations
	mockExec.On("CreateDirectory", name).Return(errors.New("error in creating file"))

	// Capture the output of Initialise
	// output := captureOutput(func() {
	// })
	Initialise(path, name)

	// assert.Contains(t, output, fmt.Sprintf("*** Creating the Service Directory %s ***", name))
	// assert.Contains(t, output, "error in creating file")

	// Assert that all expectations on the mock were met
	mockExec.AssertExpectations(t)

}

func TestInitialise_ErrorExecutingCmd(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	name := "example"

	// Set up mock expectations
	mockExec.On("CreateDirectory", name).Return(nil)
	mockExec.On("ExecuteCmds", "cd", []string{name}).Return([]byte(""), errors.New("error executing command"))

	Initialise(path, name)

	mockExec.AssertExpectations(t)
}

func TestInitialise_ErrorExecutingGoMod(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	name := "example"
	modName := fmt.Sprintf("%s/%s", path, name) 
	cmdGoStr := "go"
	cmdArgs1 := []string{"mod", "init", modName}

	// Set up mock expectations
	mockExec.On("CreateDirectory", name).Return(nil)
	mockExec.On("ExecuteCmds", "cd", []string{name}).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs1).Return([]byte(""), errors.New("error in go mod command"))

	Initialise(path, name)

	mockExec.AssertExpectations(t)
	
}

func TestInitialise_ErrorExecutingGoGets(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	name := "example"
	modName := fmt.Sprintf("%s/%s", path, name)
	cmdGoStr := "go"
	cmdArgs1 := []string{"mod", "init", modName}
	cmdArgs2 := []string{"get", "github.com/some/package"}
	DependentPackages = []string{"github.com/some/package"}

	// Set up mock expectations
	mockExec.On("CreateDirectory", name).Return(nil)
	mockExec.On("ExecuteCmds", "cd", []string{name}).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs1).Return([]byte(""),nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs2).Return([]byte(""), errors.New("error executing go get command"))

	Initialise(path, name)

	mockExec.AssertExpectations(t)
}

func TestInitialise_ErrorCreatingInitalDirectories(t *testing.T) {
	// Create a mock executor
	mockExec := mocks.NewMockCmdsExecutor()
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	name := "example"
	modName := fmt.Sprintf("%s/%s", path, name) 
	initialDirs := []string{"dir1"}
	InitialDirectories = initialDirs
	DependentPackages = []string{"github.com/some/package"}

	cmdGoStr := "go"
	cmdArgs1 := []string{"mod", "init", modName}
	cmdArgs2 := []string{"get", "github.com/some/package"}

	// Set up mock expectations
	mockExec.On("CreateDirectory", name).Return(nil)
	mockExec.On("ExecuteCmds", "cd", []string{name}).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs1).Return([]byte(""), nil)
	mockExec.On("ExecuteCmds", cmdGoStr, cmdArgs2).Return([]byte(""), nil)
	for _, dir := range InitialDirectories {
		mockExec.On("CreateDirectory", dir).Return(errors.New("error creating initial directory"))
	}

	Initialise(path, name)

	mockExec.AssertExpectations(t)
}
