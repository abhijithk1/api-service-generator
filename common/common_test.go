package common

import (
	"bytes"
	"errors"
	"io"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

// Mock for ExecuteCmds
type MockExecutor struct {
	mock.Mock
}

func (m *MockExecutor) ExecuteCmds(cmdStr string, cmdArgs []string) ([]byte, error) {
	args := m.Called(cmdStr, cmdArgs)
	return args.Get(0).([]byte), args.Error(1)
}

func (m *MockExecutor) CreateDirectory(path string) error {
	args := m.Called(path)
	return args.Error(0)
}

func (m *MockExecutor) ExecuteGoMod(path, name string) error {
	args := m.Called(path, name)
	return args.Error(0)
}

func (m *MockExecutor) ExecuteGoGets() error {
	args := m.Called()
	return args.Error(0)
}

// captureOutput captures the output of a function that writes to stdout.
func captureOutput(f func()) string {
    // Create a pipe to redirect output
    r, w, _ := os.Pipe()

    // Save the current stdout
    old := os.Stdout

    // Redirect stdout to the write end of the pipe
    os.Stdout = w

    // Close the write end of the pipe when the function exits
    defer func() {
        os.Stdout = old
        w.Close()
    }()

    // Create a channel to signal completion of the function
    done := make(chan bool)

    // Execute the function that generates output in a separate goroutine
    go func() {
        defer close(done)
        f()
    }()

    // Create a buffer to store the captured output
    var buf bytes.Buffer

    // Use a timer to prevent indefinite blocking
    timeout := time.After(5 * time.Second) // Adjust timeout as needed
    select {
    case <-done:
        // Function completed, read from the read end of the pipe to get the captured output
        io.Copy(&buf, r)
    case <-timeout:
        // Timeout occurred, close the read end of the pipe and return an empty string
        r.Close()
        return ""
    }

    // Close the read end of the pipe
    r.Close()

    // Return the captured output as a string
    return buf.String()
}

func TestMain(m *testing.M) {
	os.Exit(m.Run())
}

func TestCommandExecuter_CreateDirectory(t *testing.T) {

	path := "exampleDir"

	executer := &realCommandExecutor{}

	err := executer.CreateDirectory(path)

	assert.NoError(t, err)
	assert.DirExists(t, path)
	
	defer func() {
		err = os.RemoveAll(path)
		assert.NoError(t, err)
		assert.NoDirExists(t, path)
	}()
}

func TestCreateDirectory(t *testing.T) {

	mockExec := new(MockExecutor)

	path := "test_dir"

	mockExec.On("CreateDirectory", path).Return(nil)

	executor := mockExec

	// Create Directory
	err := executor.CreateDirectory(path)
	assert.NoError(t, err)

	mockExec.AssertExpectations(t)
}

func TestCommandExecuter_ExecuteCmds(t *testing.T) {

	// Set up test data
    cmdStr := "ls"
    cmdArgs := []string{"-l"}

	executor := &realCommandExecutor{}

	_, err := executor.ExecuteCmds(cmdStr, cmdArgs)

	assert.NoError(t, err)

}

func TestExecuteCmds(t *testing.T) {

	mockExec := new(MockExecutor)

	// Set up test data
    cmdStr := "ls"
    cmdArgs := []string{"-l"}

	mockExec.On("ExecuteCmds", cmdStr, cmdArgs).Return([]byte(""), nil)

	executor := mockExec

	_, err := executor.ExecuteCmds(cmdStr, cmdArgs)
	assert.NoError(t, err)

	mockExec.AssertExpectations(t)
}

type TestFileData struct {
	PackageName  string
	FunctionName string
}

func TestCreateFileAndItsContent_Success(t *testing.T) {
	// Create File and its content
	fileName := "test_file.go"
	fileContent := `
	//Generated By API Service Generator

	package {{.PackageName}}

	import "fmt"
	
	// {{.FunctionName}} is a function to Test and prints hello message
	func {{.FunctionName}}() {
		fmt.Println("hello")
	}
	`

	fileData := TestFileData{
		PackageName:  "common",
		FunctionName: "testingFunction",
	}

	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	require.NoError(t, err)
	require.FileExists(t, fileName)

	content, err := os.ReadFile(fileName)
	require.NoError(t, err)
	require.NotEmpty(t, content)

	// Convert content to a string
	contentStr := string(content)

	// Define expected content with actual values substituted
	expectedContent := `
	//Generated By API Service Generator

	package common

	import "fmt"
	
	// testingFunction is a function to Test and prints hello message
	func testingFunction() {
		fmt.Println("hello")
	}
	`

	require.Equal(t, normalizeWhitespace(expectedContent), normalizeWhitespace(contentStr))

	// Clean up: Remove file and its content
	defer func() {
		err = os.Remove(fileName)
		require.NoError(t, err)
		require.NoFileExists(t, fileName)
	}()
}

func normalizeWhitespace(s string) string {
	return strings.Join(strings.Fields(s), " ")
}

func TestCreateFileAndItsContent_ErrorInCreatingFile(t *testing.T) {
	// Define an invalid file path
	fileName := "/invalid_dir/test_file.go"
	fileContent := `
	package {{.PackageName}} 
	func {{.FunctionName}}() {}
	`
	fileData := TestFileData{
		PackageName:  "common",
		FunctionName: "testingFunction",
	}

	// Attempt to create file with invalid path
	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	require.Error(t, err)
	require.Contains(t, err.Error(), "error creating file")
}

func TestCreateFileAndItsContent_ErrorInParsingTemplate(t *testing.T) {
	// Define a file path
	fileName := "test_file.go"
	fileContent := `
	package {{.PackageName} 
	func {{.FunctionName}}() {}
	`
	fileData := TestFileData{
		PackageName:  "common",
		FunctionName: "testingFunction",
	}

	// Attempt to create file with invalid template
	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	require.Error(t, err)
	require.Contains(t, err.Error(), "error parsing template")

	// Clean up: Remove file if it was created
	defer func() {
		err = os.Remove(fileName)
		if err == nil || os.IsNotExist(err) {
			require.NoFileExists(t, fileName)
		}
	}()
}

func TestCreateFileAndItsContent_ErrorInExecutingTemplate(t *testing.T) {
	// Define a file path
	fileName := "test_file.go"
	fileContent := `
	package {{.PackageName}} 
	func {{.FunctionName}}() {}
	`
	fileData := struct {
		ErrorField string
	}{
		ErrorField: "error",
	}

	// Attempt to create file with mismatched data
	err := CreateFileAndItsContent(fileName, fileData, fileContent)
	require.Error(t, err)
	require.Contains(t, err.Error(), "error executing template")

	// Clean up: Remove file if it was created
	defer func() {
		err = os.Remove(fileName)
		if err == nil || os.IsNotExist(err) {
			require.NoFileExists(t, fileName)
		}
	}()
}

func TestExecuteGoMod_Success(t *testing.T) {
	mockExec := new(MockExecutor)

	path := "example/path"
	name := "example"
	// modName := fmt.Sprintf("%s/%s", path, name)

	mockExec.On("ExecuteGoMod", path, name).Return(nil)

	executer := mockExec

	err := executer.ExecuteGoMod(path, name)
	assert.NoError(t, err)
	mockExec.AssertExpectations(t)

}

func TestExecuteGoMod_MockError(t *testing.T) {
	mockExec := new(MockExecutor)
	DefaultExecutor = mockExec

	path := "example/path"
	name := "example"

	mockExec.On("ExecuteGoMod", path, name).Return(errors.New("error in initialising go module"))

	executer := mockExec

	err := executer.ExecuteGoMod(path, name)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error in initialising go module")
	mockExec.AssertExpectations(t)
}


func TestExecuteGoGets_Success(t *testing.T) {
	mockExec := new(MockExecutor)
	DefaultExecutor = mockExec

	mockExec.On("ExecuteGoGets").Return(nil)

	executer := mockExec

	err := executer.ExecuteGoGets()
	assert.NoError(t, err)
	mockExec.AssertExpectations(t)
}

func TestExecuteGoGets_Error(t *testing.T) {
	mockExec := new(MockExecutor)
	DefaultExecutor = mockExec

	DependentPackages = []string{"github.com/some/package", "github.com/another/package"}
	mockExec.On("ExecuteGoGets").Return(errors.New("error in downloading go package"))

	executer := mockExec

	err := executer.ExecuteGoGets()
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "error in downloading go package")
	mockExec.AssertExpectations(t)
}

func TestInitialise_Success(t *testing.T) {
	 // Create a mock executor
	 mockExec := new(MockExecutor)
	 DefaultExecutor = mockExec
 
	 // Set up test data
	 path := "example/path"
	 name := "example"
	 initialDirs := []string{"dir1", "dir2"}
	 InitialDirectories = initialDirs
 
	 // Set up mock expectations
	 mockExec.On("CreateDirectory", name).Return(nil)
	 mockExec.On("ExecuteCmds", "cd", []string{name}).Return([]byte(""), nil)
	 mockExec.On("ExecuteGoMod", path, name).Return(nil)
	 mockExec.On("ExecuteGoGets").Return(nil)
	 for _, dir := range initialDirs {
		 mockExec.On("CreateDirectory", dir).Return(nil)
	 }
 
	//  // Capture the output of Initialise
	//  output := captureOutput(func() {
	// })
	Initialise(path, name)
 
	//  // Assertions
	//  assert.Contains(t, output, fmt.Sprintf("*** Creating the Service Directory %s ***", name))
	//  assert.Contains(t, output, fmt.Sprintf("*** Successfully created the Service Directory %s ***", name))
	//  assert.Contains(t, output, "*** Creating go.mod ***")
	//  assert.Contains(t, output, "*** Successfully created go.mod ***")
	//  assert.Contains(t, output, "*** Updating go packages ***")
	//  assert.Contains(t, output, "*** Successfully updated go packages ***")
	//  assert.Contains(t, output, "*** the initial Directories ***")
	//  assert.Contains(t, output, "*** *** Successfully Created the initial Directories ***")
 
	 // Assert that all expectations on the mock were met
	 mockExec.AssertExpectations(t)
	
}

func TestInitialise_ErrorCreateDirectory(t *testing.T) {
	// Create a mock executor
	mockExec := new(MockExecutor)
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	name := "example"
	initialDirs := []string{"dir1", "dir2"}
	InitialDirectories = initialDirs

	// Set up mock expectations
	mockExec.On("CreateDirectory", name).Return(errors.New("error in creating file"))

	// Capture the output of Initialise
	// output := captureOutput(func() {
	// })
	Initialise(path, name)

	// assert.Contains(t, output, fmt.Sprintf("*** Creating the Service Directory %s ***", name))
	// assert.Contains(t, output, "error in creating file")

	// Assert that all expectations on the mock were met
	mockExec.AssertExpectations(t)

}

func TestInitialise_ErrorExecutingCmd(t *testing.T) {
	// Create a mock executor
	mockExec := new(MockExecutor)
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	name := "example"
	initialDirs := []string{"dir1", "dir2"}
	InitialDirectories = initialDirs

	// Set up mock expectations
	mockExec.On("CreateDirectory", name).Return(nil)
	mockExec.On("ExecuteCmds", "cd", []string{name}).Return([]byte(""), errors.New("error executing command"))

	Initialise(path, name)

	mockExec.AssertExpectations(t)
}

func TestInitialise_ErrorExecutingGoMod(t *testing.T) {
	// Create a mock executor
	mockExec := new(MockExecutor)
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	name := "example"
	initialDirs := []string{"dir1", "dir2"}
	InitialDirectories = initialDirs

	// Set up mock expectations
	mockExec.On("CreateDirectory", name).Return(nil)
	mockExec.On("ExecuteCmds", "cd", []string{name}).Return([]byte(""), nil)
	mockExec.On("ExecuteGoMod", path, name).Return(errors.New("error in go mod command"))

	Initialise(path, name)

	mockExec.AssertExpectations(t)
	
}

func TestInitialise_ErrorExecutingGoGets(t *testing.T) {
	// Create a mock executor
	mockExec := new(MockExecutor)
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	name := "example"
	initialDirs := []string{"dir1", "dir2"}
	InitialDirectories = initialDirs

	// Set up mock expectations
	mockExec.On("CreateDirectory", name).Return(nil)
	mockExec.On("ExecuteCmds", "cd", []string{name}).Return([]byte(""), nil)
	mockExec.On("ExecuteGoMod", path, name).Return(nil)
	mockExec.On("ExecuteGoGets").Return(errors.New("error executing go get command"))

	Initialise(path, name)

	mockExec.AssertExpectations(t)
}

func TestInitialise_ErrorCreatingInitalDirectories(t *testing.T) {
	// Create a mock executor
	mockExec := new(MockExecutor)
	DefaultExecutor = mockExec

	// Set up test data
	path := "example/path"
	name := "example"
	initialDirs := []string{"dir1"}
	InitialDirectories = initialDirs

	// Set up mock expectations
	mockExec.On("CreateDirectory", name).Return(nil)
	mockExec.On("ExecuteCmds", "cd", []string{name}).Return([]byte(""), nil)
	mockExec.On("ExecuteGoMod", path, name).Return(nil)
	mockExec.On("ExecuteGoGets").Return(nil)
	for _, dir := range InitialDirectories {
		mockExec.On("CreateDirectory", dir).Return(errors.New("error creating initial directory"))
	}

	Initialise(path, name)

	mockExec.AssertExpectations(t)
}
